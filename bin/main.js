// Generated by LiveScript 1.6.0
(function(){
  var C, Compilers, Toc, fs, Path, mkdirp, glob, stringHash, base58, isbinaryfile, bs, chokidar, frontMatter, onChange, pug, args, ref$, state, emptyLayout, site, tocc, watcher, allIn, allDone, writeOne, processFile, rebuild, theError, slice$ = [].slice, join$ = [].join;
  import$(global, require('ramda'));
  global.log = require('ololog').configure({
    tag: true,
    locate: false,
    stringify: {
      maxStringLength: 50,
      maxDepth: 8
    }
  });
  C = require('./config');
  Compilers = require('./compilers');
  Toc = require('./toc');
  require('ansicolor').nice;
  fs = require('fs').promises;
  Path = require('path');
  mkdirp = require('mkdirp');
  glob = require('glob');
  stringHash = require('string-hash');
  base58 = require('base58');
  isbinaryfile = require('isbinaryfile');
  bs = require('browser-sync').create();
  chokidar = require('chokidar');
  frontMatter = require('front-matter');
  onChange = require('on-change');
  pug = require('pug');
  args = require('minimist')(process.argv.slice(2), {
    'default': {
      serve: true
    }
  });
  if (args.help) {
    log('\nCommands:\n   build             compile and exit\n   watch             compile and watch for changes\n   serve             compile, watch, start local server (default)\n   proxy <port>      compile, watch, start proxy server from given port\n   \nOptions:\n   --port <number>   server port to listen (default 3000)\n');
    process.exit(0);
  }
  (ref$ = args._)[0] == null && (ref$[0] = 'serve');
  args.port == null && (args.port = 3000);
  state = {
    rescan: false,
    fileCount: 0
  };
  emptyLayout = {
    src: 'pug',
    dst: 'html',
    body: '|!{body}'
  };
  site = {};
  tocc = onChange({}, function(){
    state.rescan = true;
  });
  state.fileCount = length(glob.sync(C.source + '/**/*', {
    nodir: true
  }));
  watcher = chokidar.watch(C.source, {
    ignored: /(^|[\/\\])\../
  });
  allIn = function(){
    return state.fileCount === length(keys(site));
  };
  allDone = function(it){
    return state.fileCount === length(keys(filter(prop(it), site)));
  };
  writeOne = curry$(function(x, compiled){
    return mkdirp(Path.dirname(x.outfile)).then(function(){
      x.done = 3;
      return fs.writeFile(x.outfile, compiled);
    }).then(function(){
      log('→', x.outfile.magenta);
      return x.done = 4;
    })['catch'](theError);
  });
  processFile = function(hsh){
    var x, ref$, dir, base, ext, name, dir0, dirs, dirn, outfile;
    x = site[hsh];
    ref$ = Path.parse(x.infile), dir = ref$.dir, base = ref$.base, ext = ref$.ext, name = ref$.name;
    ref$ = split('/', dir), dir0 = ref$[1], dirs = slice$.call(ref$, 2);
    dirn = join$.call(dirs, '/') || '';
    if (isbinaryfile.isBinaryFileSync(x.infile)) {
      outfile = Path.join(C.outroot, dir0 != null ? dir0 : '', dirn, base);
      mkdirp(Path.dirname(outfile)).then(function(){
        return fs.copyFile(x.infile, outfile);
      }).then(function(){
        log('░', outfile.cyan);
        return x.done = 4;
      });
      return;
    }
    return fs.readFile(x.infile).then(function(it){
      var src, dst, fm, body, attr, bust, pj, outfile, link, tocEntry;
      src = tail(ext);
      dst = defaultTo(src)(
      prop('0')(
      find(compose$(function(it){
        return it[1];
      }, has(src)))(
      toPairs(Compilers.formats))));
      fm = frontMatter(it.toString());
      body = fm.body;
      attr = ifElse(function(it){
        return it.ignore;
      }, empty, identity)(
      fm.attributes);
      bust = attr['bust-cache'] ? (log('bust-cache?'), state.rescan = true, '-' + base58.int_to_base58(stringHash(body))) : '';
      pj = Path.join;
      outfile = (function(){
        switch (false) {
        case !attr.index:
          return pj(C.outroot, 'index.html');
        case dir0 !== 'html':
          return pj(C.outroot, dirn, name, 'index.html');
        case !dst:
          return pj(C.outroot, dir0 != null ? dir0 : '', dirn, name + "" + bust + "." + dst);
        default:
          return pj(C.outroot, dir0 != null ? dir0 : '', dirn, base);
        }
      }());
      link = (function(){
        switch (false) {
        case !attr.index:
          return '';
        case dir0 !== 'html':
          return pj(dirn, name);
        case !dst:
          return pj(dir0 != null ? dir0 : '', dirn, name + "" + bust + "." + dst);
        }
      }());
      tocEntry = attr.toc || attr.eleventyNavigation;
      if (dst === 'html') {
        switch (false) {
        case !tocEntry:
          import$(tocc[hsh] || (tocc[hsh] = {}), tocEntry);
          x.toc = {
            key: tocEntry.key,
            ord: tocEntry.order,
            lnk: link,
            hsh: hsh
          };
          break;
        case !tocc[hsh]:
          tocc[hsh] = {};
        }
      }
      delete attr.toc;
      delete attr.eleventyNavigation;
      x.outfile = outfile;
      x.body = body;
      x.dst = dst;
      x.attr = attr;
      x.link = link;
      x.src = src;
      return Promise.resolve((function(){
        switch (false) {
        case !x.attr.template:
          x.done = 1.5;
          log('template'.red, x.infile.blue);
          return state.rescan = true;
        default:
          return Compilers.compile(dst, src, body, outfile, attr.options).then(function(compiled){
            switch (false) {
            case !(x.dst === 'html' && x.attr.layout !== 'none'):
              return x.cpld = compiled, x.done = 2, x;
            default:
              return writeOne(x, compiled);
            }
          });
        }
      }())).then(function(){
        if (allIn() && (state.rescan || all(compose$(function(it){
          return it.done;
        }, (function(it){
          return it > 1;
        })), values(site)))) {
          return Promise.all(rebuild(state.rescan)).then(function(){
            if (args._[0] === 'build' && all(propEq('done', 4), values(site))) {
              return process.exit(0);
            }
          });
        }
      });
    })['catch'](theError);
  };
  rebuild = function(rescan){
    var toc, css, js, writes;
    state.rescan = false;
    toc = reduce(mergeDeepRight, {})(
    map(function(x){
      return assocPath(__, {
        $: x.toc
      }, {})(
      intersperse('_')(
      split('/')(
      x.link)));
    })(
    filter(function(it){
      return it.toc;
    })(
    values(site))));
    css = join('')(
    map(function(it){
      return "<link rel=stylesheet href='/" + it.link + "'>";
    })(
    sortBy(function(it){
      return it.attr.order;
    })(
    filter(function(it){
      return it.attr['bust-cache'];
    })(
    filter(propEq('dst', 'css'))(
    values(site))))));
    js = [];
    return writes = map(function(x){
      var layoutName, layout, ref$, ref1$;
      x.done = 3;
      layoutName = x.attr.layout || 'system';
      layout = (function(it){
        return it || emptyLayout;
      })(
      find(pathEq(['attr', 'template'], layoutName))(
      values(site)));
      return Compilers.compile(layout.dst, layout.src, layout.body, x.outfile, (ref$ = {}, import$(ref$, x.attr), ref$.body = x.cpld, ref$.toc = Toc.build({
        _: toc,
        hsh: (ref1$ = x.toc) != null ? ref1$.hsh : void 8
      }), ref$.css = css, ref$.js = js, ref$)).then(writeOne(x)).then(function(){
        return layout.done = 4;
      });
    })(
    filter(ifElse(always(rescan), has('cpld'), propEq('done', 2)))(
    values(site)));
  };
  theError = function(it){
    switch (it != null && it.name) {
    case 'Error':
      log.error.yellow(it);
      break;
    default:
      log.error.red(it);
    }
    process.exit(1);
  };
  watcher.on('ready', function(){
    if (state.fileCount === 0) {
      log.warn("“" + C.source + "” is empty or doesn't exit");
    } else {
      log.info("found " + state.fileCount + " files");
    }
    switch (args._[0]) {
    case 'serve':
      bs.init({
        files: C.outroot,
        server: C.outroot,
        watch: true
      });
      break;
    case 'proxy':
      bs.init({
        port: args.port,
        files: C.outroot,
        watch: true,
        proxy: {
          target: "http://localhost:" + args._[1],
          ws: true
        }
      });
    }
  });
  watcher.on('all', function(event, infile){
    var hash, bin;
    hash = stringHash(infile);
    switch (event) {
    case 'add':
      if (allIn()) {
        ++state.fileCount;
      }
      // fallthrough
    case 'change':
      bin = isbinaryfile.isBinaryFileSync(infile);
      site[hash] = {
        infile: infile,
        done: 1,
        bin: bin
      };
      processFile(hash);
      break;
    case 'unlink':
      --state.fileCount;
      fs.unlink(site[hash].outfile);
      delete tocc[hash];
      delete site[hash];
      break;
    default:
      return;
    }
    log(event, infile.yellow);
  });
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
}).call(this);
