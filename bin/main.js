// Generated by LiveScript 1.6.0
(function(){
  var C, Compilers, Toc, fs, Path, mkdirp, glob, stringHash, base58, log, bs, chokidar, frontMatter, onChange, pug, state, site, tocc, watcher, allDone, writeOne, processFile, rebuild, theError, slice$ = [].slice, join$ = [].join;
  import$(global, require('ramda'));
  C = require('./config');
  Compilers = require('./compilers');
  Toc = require('./toc');
  require('ansicolor').nice;
  fs = require('fs').promises;
  Path = require('path');
  mkdirp = require('mkdirp');
  glob = require('glob');
  stringHash = require('string-hash');
  base58 = require('base58');
  log = require('ololog').configure({
    tag: true,
    locate: false,
    stringify: {
      maxStringLength: 50,
      maxDepth: 8
    }
  });
  bs = require('browser-sync').create();
  chokidar = require('chokidar');
  frontMatter = require('front-matter');
  onChange = require('on-change');
  pug = require('pug');
  state = {
    rescan: false,
    filecount: 0,
    mode: ''
  };
  site = {};
  tocc = onChange({}, function(){
    state.rescan = true;
  });
  state.mode = (function(){
    switch (process.argv[2]) {
    case 'build':
      return '';
    case 'watch':
      return 'w';
    default:
      return 'bw';
    }
  }());
  watcher = chokidar.watch(C.source, {
    ignored: /(^|[\/\\])\../
  });
  allDone = function(){
    return state.fileCount === length(keys(filter(function(it){
      return it.ping;
    }, site)));
  };
  writeOne = curry$(function(x, compiled){
    x.wrtn = true;
    return mkdirp(Path.dirname(x.outfile)).then(function(){
      return fs.writeFile(x.outfile, compiled);
    }).then(function(){
      return log('â†’', x.outfile.magenta);
    })['catch'](theError);
  });
  processFile = function(hsh){
    var x, ref$, dir, base, ext, name, dir0, dirs, dirn;
    x = site[hsh];
    ref$ = Path.parse(x.infile), dir = ref$.dir, base = ref$.base, ext = ref$.ext, name = ref$.name;
    ref$ = split('/', dir), dir0 = ref$[1], dirs = slice$.call(ref$, 2);
    dirn = join$.call(dirs, '/') || '';
    return fs.readFile(x.infile).then(function(it){
      var src, dst, fm, ref$, body, attr, bust, pj, outfile, link, tocEntry;
      src = tail(ext);
      dst = defaultTo(src)(
      prop('0')(
      find(compose$(function(it){
        return it[1];
      }, has(src)))(
      toPairs(Compilers.formats))));
      fm = frontMatter(it.toString());
      ref$ = [fm.body, fm.attributes], body = ref$[0], attr = ref$[1];
      bust = attr['bust-cache'] ? (state.rescan = true, '-' + base58.int_to_base58(stringHash(body))) : '';
      pj = Path.join;
      outfile = (function(){
        switch (false) {
        case !attr.index:
          return pj(C.outroot, 'index.html');
        case dir0 !== 'html':
          return pj(C.outroot, dirn, name, 'index.html');
        case !dst:
          return pj(C.outroot, dir0 != null ? dir0 : '', dirn, name + "" + bust + "." + dst);
        default:
          return pj(C.outroot, dir0 != null ? dir0 : '', dirn, base);
        }
      }());
      link = (function(){
        switch (false) {
        case !attr.index:
          return '';
        case dir0 !== 'html':
          return pj(dirn, name);
        case !dst:
          return pj(dir0 != null ? dir0 : '', dirn, name + "" + bust + "." + dst);
        }
      }());
      x.ping = true;
      tocEntry = attr.toc || attr.eleventyNavigation;
      if (tocEntry) {
        import$(tocc[hsh] || (tocc[hsh] = {}), tocEntry);
        x.toc = {
          key: tocEntry.key,
          ord: tocEntry.order,
          lnk: link,
          hsh: hsh
        };
      } else {
        delete tocc[hsh];
      }
      x.outfile = outfile;
      x.body = body;
      x.dst = dst;
      x.attr = attr;
      x.link = link;
      x.src = src;
      if (x.attr.template) {
        log('template'.red, x.infile.blue);
        state.rescan = true;
      } else {
        Compilers.compile(dst, src, body, outfile).then(function(compiled){
          var ref$;
          switch (false) {
          case !(x.dst !== 'html' || ((ref$ = x.attr) != null ? ref$.layout : void 8) === 'none'):
            return writeOne(x, compiled);
          default:
            x.wrtn = false;
            return x.cpld = compiled, x;
          }
        });
      }
      if (allDone()) {
        return rebuild(state.rescan);
      }
    })['catch'](theError);
  };
  rebuild = function(full){
    var toc, css, writes;
    toc = reduce(mergeDeepRight, {})(
    map(function(x){
      return assocPath(__, {
        $: x.toc
      }, {})(
      intersperse('_')(
      split('/')(
      x.link)));
    })(
    filter(function(it){
      return it.toc;
    })(
    values(site))));
    css = join('')(
    map(function(it){
      return "<link rel=stylesheet href='/" + it.link + "'>";
    })(
    sortBy(function(it){
      return it.attr.order;
    })(
    filter(function(it){
      return it.attr['bust-cache'];
    })(
    filter(propEq('dst', 'css'))(
    values(site))))));
    state.rescan = false;
    writes = map(function(x){
      var layoutName, layout;
      layoutName = x.attr.layout || 'system';
      layout = (function(it){
        return it || (function(){
          throw Error("no layout named: " + layoutName);
        }());
      })(
      find(pathEq(['attr', 'template'], layoutName))(
      values(site)));
      return Compilers.compile(layout.dst, layout.src, layout.body, x.outfile, {
        body: x.cpld,
        toc: Toc.build({
          _: toc
        }),
        css: css
      }).then(writeOne(x));
    })(
    filter(compose$(function(it){
      return it.wrtn;
    }, not$, (function(it){
      return full || it;
    })))(
    filter(compose$(hasPath(['attr', 'template']), not$))(
    filter(compose$(pathEq(['attr', 'layout'], 'none'), not$))(
    filter(propEq('dst', 'html'))(
    values(site))))));
    Promise.all(writes).then(function(){
      log.green('Ready.');
      if (state.mode === '') {
        process.exit(0);
      }
    });
  };
  theError = function(it){
    switch (it != null && it.name) {
    case 'Error':
      log.error.bgMagenta(it.message);
      break;
    default:
      log.error.red(it);
    }
    process.exit(1);
  };
  watcher.on('ready', function(){
    if (!state.mode.match(/b/)) {
      return;
    }
    bs.init({
      server: C.outroot,
      watch: C.outroot
    });
  });
  watcher.on('all', function(event, infile){
    var hash;
    state.fileCount = length(glob.sync(C.source + '/**/*', {
      nodir: true
    }));
    hash = stringHash(infile);
    switch (event) {
    case 'add':
    case 'change':
      site[hash] = {
        infile: infile
      };
      processFile(hash);
      break;
    case 'unlink':
      fs.unlink(site[hash].outfile);
      delete tocc[hash];
      delete site[hash];
      break;
    default:
      return;
    }
    log(event, infile.yellow);
  });
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function not$(x){ return !x; }
}).call(this);
